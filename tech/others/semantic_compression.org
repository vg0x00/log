* semantic compression programming

** OOP 
  OOP 中, 开发之初一般是将问题抽象成模型, 再将模型细化为类, 并通过UML 这种virtual map 的形式将
  类之间的关系和接口表达清楚. 随后开始码字.将问题单元进行对象化, 还引入了继承, 甚至多重继承来增加对
  现实问题模型的模拟度. 这种思考方式的最初, 偏离了问题的本源, 而直接开始抽象, 分解. 如果要完成"高复用,
  灵活拓展, 易于维护" 的代码, 那么设计环节的脑力似乎占比会更大. 且不保证在后续的实践环节中暴露出这种纯
  设计带来的问题.

  高复用代码要求还是有点漂浮, 还是先保证代码能用吧.

  程序编写应该是直接的, 如果将问题的解决步骤做到最佳, 那么将其用最佳的编程语言加以表达似乎也是顺水推舟.
  
** semantic compression programming
   
   原文: [[https://mollyrocket.com/casey/stream_0019.html][casey blog - Semantic Compression]] 
   
   - 如果代码在开发中重复出现至少两次才有必要抽离出函数进行复用, 不要over engineering 而事先规划好哪些
     部分可能会复用
   - 将重复代码中的变量进行抽离, 放入一个struct, 这就形成了data
   - 将重复的代码进行抽离, 并根据功能进行划分, 这样就形成方法
   - 通过以上两个环节, 形成了对象{data, methods}
   - 调用过程可以束缚于data上, 形成类似OOP 调用形式, 当然也可以和过程化编程一样. 进行函数嵌套调用.

   相比较开篇提到的OOP思路, 这种semantic compression 是自下而上的逻辑, 从问题解决方案出发, 抽离数据和
   方法, 最后也形成了对象化的模型.

   不得不说, 这种思路有点原始, 与当今大行其道的OOP有点背道而驰. 但其面向解决问题的过程, 似乎这才是编程根本.
   
   这种思路出来的代码最大的优势就是代码会非常直接, 如果你明白问题本来如何处理, 那么代码逻辑是显而易见的, 基本就是
   直接翻译. 如果不清楚问题的解决, 那么精练后的语义表达我想也比搞清楚对象之间的关系以及他们之间如何传递Message
   来得直接.
   
